ğ—–ğ—¿ğ—²ğ—®ğ˜ğ—¶ğ—»ğ—´ ğ—® ğ—–ğ˜‚ğ˜€ğ˜ğ—¼ğ—º ğ—ğ—¼ğ˜ğ—¹ğ—¶ğ—» ğ—¦ğ—²ğ—¾ğ˜‚ğ—²ğ—»ğ—°ğ—² ğ—¢ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿

Many of us use sequences in our projects and work with a variety of operators, but do you know how they work under the hood? Letâ€™s create a custom operator that filters only odd-indexed elements and explore how to implement it, following examples from the Kotlin Sequence API.

ğ—›ğ—¼ğ˜„ ğ—¦ğ—²ğ—¾ğ˜‚ğ—²ğ—»ğ—°ğ—²ğ˜€ ğ—ªğ—¼ğ—¿ğ—¸ ğ—¶ğ—» ğ—ğ—¼ğ˜ğ—¹ğ—¶ğ—»

Each  in Kotlin is an interface that exposes an :

ğ˜±ğ˜¶ğ˜£ğ˜­ğ˜ªğ˜¤ ğ˜ªğ˜¯ğ˜µğ˜¦ğ˜³ğ˜§ğ˜¢ğ˜¤ğ˜¦ ğ˜šğ˜¦ğ˜²ğ˜¶ğ˜¦ğ˜¯ğ˜¤ğ˜¦<ğ˜°ğ˜¶ğ˜µ ğ˜›> {
    ğ˜±ğ˜¶ğ˜£ğ˜­ğ˜ªğ˜¤ ğ˜°ğ˜±ğ˜¦ğ˜³ğ˜¢ğ˜µğ˜°ğ˜³ ğ˜§ğ˜¶ğ˜¯ ğ˜ªğ˜µğ˜¦ğ˜³ğ˜¢ğ˜µğ˜°ğ˜³(): ğ˜ğ˜µğ˜¦ğ˜³ğ˜¢ğ˜µğ˜°ğ˜³<ğ˜›>
}

To implement a custom Sequence operator, we can create a class that implements this interface. All we need is to iterate through the elements, apply transformations, and return a resulting sequence.

ğ—œğ—ºğ—½ğ—¹ğ—²ğ—ºğ—²ğ—»ğ˜ğ—®ğ˜ğ—¶ğ—¼ğ—»

Hereâ€™s our class:

ğ˜¤ğ˜­ğ˜¢ğ˜´ğ˜´ ğ˜–ğ˜¥ğ˜¥ğ˜šğ˜¦ğ˜²ğ˜¶ğ˜¦ğ˜¯ğ˜¤ğ˜¦<ğ˜›>(ğ˜±ğ˜³ğ˜ªğ˜·ğ˜¢ğ˜µğ˜¦ ğ˜·ğ˜¢ğ˜­ ğ˜´ğ˜°ğ˜¶ğ˜³ğ˜¤ğ˜¦: ğ˜šğ˜¦ğ˜²ğ˜¶ğ˜¦ğ˜¯ğ˜¤ğ˜¦<ğ˜›>) : ğ˜šğ˜¦ğ˜²ğ˜¶ğ˜¦ğ˜¯ğ˜¤ğ˜¦<ğ˜›> {
    ğ˜°ğ˜·ğ˜¦ğ˜³ğ˜³ğ˜ªğ˜¥ğ˜¦ ğ˜§ğ˜¶ğ˜¯ ğ˜ªğ˜µğ˜¦ğ˜³ğ˜¢ğ˜µğ˜°ğ˜³(): ğ˜ğ˜µğ˜¦ğ˜³ğ˜¢ğ˜µğ˜°ğ˜³<ğ˜›> = ğ˜–ğ˜¥ğ˜¥ğ˜—ğ˜°ğ˜´ğ˜ªğ˜µğ˜ªğ˜°ğ˜¯ğ˜ğ˜µğ˜¦ğ˜³ğ˜¢ğ˜µğ˜°ğ˜³(ğ˜´ğ˜°ğ˜¶ğ˜³ğ˜¤ğ˜¦)
}

This class uses a form of the ğ—±ğ—²ğ—°ğ—¼ğ—¿ğ—®ğ˜ğ—¼ğ—¿ ğ—½ğ—®ğ˜ğ˜ğ—²ğ—¿ğ—» â€” we decorate the iteration process of the upstream sequence. The  class takes the upstream sequence, iterates over it, selects elements at odd positions, and passes them to its iterator.

Now, we need a specialized iterator to check whether an elementâ€™s index is odd or even. To simplify the implementation, we use , which is a utility class that helps calculate the next element lazily when  or  is called.

Hereâ€™s what the iterator looks like. It iterates through the upstream sequence, finds the next odd-positioned element, and adds it using . When no elements remain, we call .

ğ˜ªğ˜¯ğ˜µğ˜¦ğ˜³ğ˜¯ğ˜¢ğ˜­ ğ˜¤ğ˜­ğ˜¢ğ˜´ğ˜´ ğ˜–ğ˜¥ğ˜¥ğ˜—ğ˜°ğ˜´ğ˜ªğ˜µğ˜ªğ˜°ğ˜¯ğ˜ğ˜µğ˜¦ğ˜³ğ˜¢ğ˜µğ˜°ğ˜³<ğ˜›>(ğ˜´ğ˜°ğ˜¶ğ˜³ğ˜¤ğ˜¦: ğ˜šğ˜¦ğ˜²ğ˜¶ğ˜¦ğ˜¯ğ˜¤ğ˜¦<ğ˜›>) : ğ˜ˆğ˜£ğ˜´ğ˜µğ˜³ğ˜¢ğ˜¤ğ˜µğ˜ğ˜µğ˜¦ğ˜³ğ˜¢ğ˜µğ˜°ğ˜³<ğ˜›>() {
    ğ˜±ğ˜³ğ˜ªğ˜·ğ˜¢ğ˜µğ˜¦ ğ˜·ğ˜¢ğ˜³ ğ˜ªğ˜¯ğ˜¥ğ˜¦ğ˜¹ = 0
    ğ˜±ğ˜³ğ˜ªğ˜·ğ˜¢ğ˜µğ˜¦ ğ˜·ğ˜¢ğ˜­ ğ˜ªğ˜µğ˜¦ğ˜³ğ˜¢ğ˜µğ˜°ğ˜³ = ğ˜´ğ˜°ğ˜¶ğ˜³ğ˜¤ğ˜¦.ğ˜ªğ˜µğ˜¦ğ˜³ğ˜¢ğ˜µğ˜°ğ˜³()

    ğ˜°ğ˜·ğ˜¦ğ˜³ğ˜³ğ˜ªğ˜¥ğ˜¦ ğ˜§ğ˜¶ğ˜¯ ğ˜¤ğ˜°ğ˜®ğ˜±ğ˜¶ğ˜µğ˜¦ğ˜•ğ˜¦ğ˜¹ğ˜µ() {
        ğ˜¸ğ˜©ğ˜ªğ˜­ğ˜¦ (ğ˜ªğ˜µğ˜¦ğ˜³ğ˜¢ğ˜µğ˜°ğ˜³.ğ˜©ğ˜¢ğ˜´ğ˜•ğ˜¦ğ˜¹ğ˜µ()) {
            ğ˜ªğ˜¯ğ˜¥ğ˜¦ğ˜¹++

            ğ˜·ğ˜¢ğ˜­ ğ˜¯ğ˜¦ğ˜¹ğ˜µ = ğ˜ªğ˜µğ˜¦ğ˜³ğ˜¢ğ˜µğ˜°ğ˜³.ğ˜¯ğ˜¦ğ˜¹ğ˜µ()

            ğ˜ªğ˜§ (ğ˜ªğ˜´ğ˜Œğ˜­ğ˜ªğ˜¨ğ˜ªğ˜£ğ˜­ğ˜¦()) {
                ğ˜´ğ˜¦ğ˜µğ˜•ğ˜¦ğ˜¹ğ˜µ(ğ˜¯ğ˜¦ğ˜¹ğ˜µ)
                ğ˜³ğ˜¦ğ˜µğ˜¶ğ˜³ğ˜¯
            }
        }
        ğ˜¥ğ˜°ğ˜¯ğ˜¦()
    }

    ğ˜±ğ˜³ğ˜ªğ˜·ğ˜¢ğ˜µğ˜¦ ğ˜§ğ˜¶ğ˜¯ ğ˜ªğ˜´ğ˜Œğ˜­ğ˜ªğ˜¨ğ˜ªğ˜£ğ˜­ğ˜¦() = ğ˜ªğ˜¯ğ˜¥ğ˜¦ğ˜¹ % 2 != 0
}

At this point, you might be wondering, â€œHow do I use this in practice?â€ Itâ€™s simple:

ğ˜§ğ˜¶ğ˜¯ <ğ˜›> ğ˜šğ˜¦ğ˜²ğ˜¶ğ˜¦ğ˜¯ğ˜¤ğ˜¦<ğ˜›>.ğ˜µğ˜¢ğ˜¬ğ˜¦ğ˜–ğ˜¥ğ˜¥ğ˜—ğ˜°ğ˜´ğ˜ªğ˜µğ˜ªğ˜°ğ˜¯ğ˜´() = ğ˜–ğ˜¥ğ˜¥ğ˜šğ˜¦ğ˜²ğ˜¶ğ˜¦ğ˜¯ğ˜¤ğ˜¦(ğ˜µğ˜©ğ˜ªğ˜´)

ğ˜§ğ˜¶ğ˜¯ ğ˜®ğ˜¢ğ˜ªğ˜¯() {
    (1..100).ğ˜¢ğ˜´ğ˜šğ˜¦ğ˜²ğ˜¶ğ˜¦ğ˜¯ğ˜¤ğ˜¦()
        .ğ˜µğ˜¢ğ˜¬ğ˜¦ğ˜–ğ˜¥ğ˜¥ğ˜—ğ˜°ğ˜´ğ˜ªğ˜µğ˜ªğ˜°ğ˜¯ğ˜´()
        .ğ˜°ğ˜¯ğ˜Œğ˜¢ğ˜¤ğ˜© { ğ˜±ğ˜³ğ˜ªğ˜¯ğ˜µğ˜­ğ˜¯("ğ˜ğ˜ªğ˜­ğ˜µğ˜¦ğ˜³ğ˜¦ğ˜¥ ğ˜¦ğ˜­ğ˜¦ğ˜®ğ˜¦ğ˜¯ğ˜µ: $ğ˜ªğ˜µ") }
        .ğ˜µğ˜°ğ˜“ğ˜ªğ˜´ğ˜µ()
}

You just create an extension function on  to apply the operator and youâ€™re ready to go.

ğ—–ğ—¼ğ—»ğ—°ğ—¹ğ˜‚ğ˜€ğ—¶ğ—¼ğ—»

By exploring the implementation of operators you use in your code, you'll gain a deeper understanding of how they work. You'll often encounter similar patterns involving iterators, extension functions, and lazy computation. Some iterators may include predicates, transformation functions, or parameters for dropping or taking elements, but the fundamental concepts remain the same.